package types

import (
	"bytes"
	"fmt"
	// "os"
)


const SchemaVersion = 4

type Package struct {
	GoPackagePath string 
	Version       string 
	Hash          string 
	ReplacedPath  string 
}

type Output struct {
	SchemaVersion int                
	Mod           map[string]*Package

	// Packages with passed import paths trigger `go install` based on this list
	SubPackages []string

	// Packages with passed import paths has a "default package" which pname & version is inherit from
	GoPackagePath string
}

func Marshal(pkgs []*Package, goPackagePath string, subPackages []string) ([]byte, error) {
	out := &Output{
		SchemaVersion: SchemaVersion,
		Mod:           make(map[string]*Package),
		SubPackages:   subPackages,
		GoPackagePath: goPackagePath,
	}

	for _, pkg := range pkgs {
		out.Mod[pkg.GoPackagePath] = pkg
	}

	var buf bytes.Buffer

	// TODO create nix serialization library
	buf.WriteString("# Generated by gomod2nix\n{ pkgs, lib, ... }:\n{\n")
	buf.WriteString(fmt.Sprintf("  schemaVersion = %d;\n", SchemaVersion))
	for name, pkg := range out.Mod {
		buf.WriteString(fmt.Sprintf("  mod.\"%s\" = { version = \"%s\"; hash = \"%s\"; replacedPath = \"%s\"; };\n", name, pkg.Version, pkg.Hash, pkg.ReplacedPath))
	}
	// TODO SubPackages, GoPackagePath
	buf.WriteString("}\n")

	return buf.Bytes(), nil
}

func ReadCache(filePath string) map[string]*Package {
	ret := make(map[string]*Package)

	// TODO parse nix
	// if filePath == "" {
	// 	return ret
	// }

	// b, err := os.ReadFile(filePath)
	// if err != nil {
	// 	return ret
	// }

	// var output Output
	// _, err = toml.Decode(string(b), &output)
	// if err != nil {
	// 	return ret
	// }

	// if output.SchemaVersion != SchemaVersion {
	// 	return ret
	// }

	// for k, v := range output.Mod {
	// 	v.GoPackagePath = k
	// 	ret[k] = v
	// }

	return ret
}
